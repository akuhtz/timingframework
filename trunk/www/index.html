<html>
    <head>
        <title>Timing is Everything</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    </head>
    <body text="#000000" bgColor="#ffffff">
        <center>
        <h1>Timing is Everything</h1>
        <h3>Chet Haase</h3>
        </center>
        <p>Welcome to the <b>Timing Framework</b>, a library for making Java animation
            and timing-based control easier. There are two articles on java.net
            that describe some of the fundamentals: 
            <a href="http://today.java.net/pub/a/today/2005/02/15/timing.html">Timing 
            is Everything</a> and 
            <a href="http://today.java.net/pub/a/today/2006/03/16/time-again.html">Time Again</a>;
            these articles will serve as a good introduction to the framework,
            although some of the API particulars have changed since the articles
            were published.
        </p>
        <p>
            Ongoing changes to the library are documented in the <a href="#Changes">Changes</a> 
            section below.  <a href="https://timingframework.dev.java.net/servlets/ProjectForumView">Forums</a> 
            are now active for questions, bugs, and suggestions.
        </p>
        <h2>The Library</h2>
        <P>The library is divided into three logical parts, which make up the
            three packages:
            <ul>
                <li>Fundamentals: org.jdesktop.animation.timing</li>
                <li>Interpolation: org.jdesktop.animation.timing.interpolation</li>
                <li>Triggers: org.jdesktop.animation.timing.triggers</li>
            </ul>
            </p>
            <p>
            <b>Fundamentals</b> is described fairly completely in the original
            "Timing is Everything" article, although some of the names have
            changed and some of the classes have merged.  
            These classes include the base
            Animator object (which used to be called "TimingController")
            that actually runs the animation and the TimingTarget interface,
            and its adapter class TimingTargetAdapter,
            which are used to receive timing events.
            </p>
            <p>
            <b>Interpolation</b> is desribed in the second article,
            "Time Again", but here are the core concepts:
            <ul>
                <li>
                Property Setters: Easy delegation of property animation to the framework (like 
                changing the size of a component over time, for example).  This
                capability is handled by the class PropertySetter (a class
                which merges the original classes <code>PropertyRange</code> and 
                <code>ObjectModifier</code>.
                </li>
                <li>
                KeyFrames: More powerful and complex animations via multi-step sequences of 
                time/value pairs.  KeyFrames combines the objects <code>KeyTimes</code>,
                <code>KeyValues</code>, and <code>Interpolator</code>.
                </li>
                <li>
                Non-Linear Interpolation: More interesting and useful animations by specifying 
                non-linear paths for time interpolation.  This capability is
                controlled through the use of the <code>Interpolator</code>
                interface, which can be overridden to provide arbitrary 
                interpolation values for any input, or by using one of the
                built-in subclasses: <code>LinearInterpolator</code> (the default
                where none is provided), <code>DiscreteInterpolator</code>, and
                <code>SplineInterpolator</code> (which provides an built-in mechanism
                for creating spline-based interpolation).
                </li>
                <li>
                Acceleration/deceleration: Easy specification of simple non-linear behavior by 
                telling the Animator periods of acceleration and deceleration during 
                the normal time fraction.
                </li>
            </ul>
            <p>
            <b>Triggers</b> contain support
            for easy starting/stopping of animations based on events.  Triggers
            basically wrap event listener handling and simplify sequencing
            animations based on events
            substantially.  Instead of writing various listeners to track
            events and fire off animations appropriately in your code, 
            you can set up Triggers to do the listening and starting/stopping
            for you.  The intent is to make it easier to have canonical
            effects on GUI components, like pulsating buttons, components
            that animate to a focus state, etc.
            Check out the Triggers demo to see what I mean (until I get a
            chance to document it better than this admittedly brief paragraph).
        </P>
        <p>There are various new and old demos in the demos directory.  You should
        be able to checkout that directory from CVS and get entire build tree
        for NetBeans, or you can just look at the files one by one.  The demos 
        include:
        <ul>
            <li>ButtonAnimation: This is a nuts-and-bolts view of most of the
            capabilities of the framework.  It allows you to tweak the various
            options of the framework and see the effects on basic Swing button
            rendering.</li>
            <li>DiscreteInterpolation: This one is so basic it probably should
            not even be here, but heck I wrote it so I might as well post it.
            It shows how you might use DISCRETE interpolation to change 
            values of objects (in this case, the String displayed in the
            window) over time.  It shows basic usage of the KeyFrames,
            KeyTimes, KeyValues, and SplineInterpolator classes in the
            interpolation package.  It also uses a simple Trigger to kick
            off the animation.</li>
            <li>Triggers: Another unattractive demo, but it shows how you can
            use some of the new Triggers to automatically kick off animations
            based on GUI events.</li>
            <li>Racetrack: There are several demos in this package (BasicRace,
            SetterRace, TriggerRace, NonLinearRace, and MultiStepRace) which were used in
            our JavaOne presentation to show how the various features of the
            framework work.  The demo gets more interesting, and uses more
            framework features, as you progress through the demos in the order
            listed above (MultiStepRace shows off most of the framework
            functionality).  Graphics and sound effects provided by the
            one and only Romain Guy (thanks Romain!)</li>
            <li>SplineEditor: This is a beautiful demo by Romain Guy that
            helps visualize the effect of various Spline curves on any
            particular animation.  You can choose several pre-made Splines or
            drag the points to create your own and see the resulting
            animation.  Great for getting a handle on how spline-based non-linear
            interpolation works in the framework.</li>
        </ul>
        </p>
        <p>
        <h2>Demos</h2>
        <p>To run the demos, download the files from the appropriate version
        in the <A href="https://timingframework.dev.java.net/servlets/ProjectDocumentList">downloads directory</A>.  This directory 
        contains specific versions of the javadocs, library sources,
        demos jarfile, demos sources, and framework jarfile
            Then you can run any of the demos as follows (note that you'll
            have to adjust the command-line to account for the version
            numbers):
            <pre>
                java -cp TimingFramework.jar;TimingExamples.jar DEMO
            </pre>
            where DEMO is one of:
            <ul>
                <li>org.jdesktop.animation.timing.examples.ButtonAnimation</li>
                <li>org.jdesktop.animation.timing.examples.DiscreteInterpolation</li>
                <li>org.jdesktop.animation.timing.examples.Triggers</li>
                <li>org.jdesktop.animation.timing.examples.ExternalTimer</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.BasicRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.SetterRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.TriggerRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.NonLinearRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.MultiStepRace</li>
                <li>org.jdesktop.animation.timing.examples.editor.SplineEditor</li>
            </ul>
        <P>
            <h2>Project Details</h2>
        </P>
        <p>This project is NetBeans-friendly, so you should be able to download the 
            project and build it easily. I'm running in NetBeans 5.0, in case you need that 
            version to interpret the project files correctly.
        </p>
        <p>The main things to check out here are the Articles mentioned above and
        all of the items in the <A href="https://timingframework.dev.java.net/servlets/ProjectDocumentList">downloads directory</A> 
        (the source code, the library,
        the demos, and the JavaDocs).
            Note that the library is dependent upon JDK 5.0, so 
            you will need 5.0 to run it or build against it.  I use 5.0 because
            generics and varargs helped provide a nice way to get a lot of different
            PropertySetter and KeyValues variants in a very compact way.
        </p>
        <p>The project is still read-only for now; this is because the project is still 
            very much in flux, but it's also because I want to make sure that any 
            interesting developments in the project can be pulled into Java SE if 
            appropriate; after all, if there are useful timing utilities that people need, 
            why not put them into core where they belong? I hope to change that eventually 
            (probably by using a JCA license like SwingLabs does), but for now feel free to 
            browse, download, and build the source, or to just use the library as you see 
            fit. I'm thinking that's all that most people want for now anyway...
        </p>
        <p>
            For those folks that got here by reading the original Timing is Everything 
            article, I've cached a zipped version of the original source code in <A href="articleSrc.zip">
                articleSrc.zip</A>, although I'd just suggest reading the second article 
            and using the current source instead; lots of things in the latest library to 
            make life with Timing Framework much easier than with the original version.
        </p>
        <P>
            Check back for future changes. I think the latest round of changes is quite 
            powerful and will enable some great animations in Swing applications, but 
            there's more work to be done...</P>
        <p>
            <i>I would like to thank Christopher Campbell, Hans Muller, Scott Violet, Romain 
                Guy, and Vincent Hardy for contributing to ideas and code in both the article 
                and project. This article and project took a while to incubate and the 
                assistance of these people hopefully made the end result better than it 
                otherwise would have been.</i>
        </p>
        <P>
            <p>
            <a name="Changes"><b>Change Log:</b></a>
            </p>
            <p>March 30, 2007, Version 0.55: External Timers, minor API tweaks</p>
            <p>
            <ul>
                <li>API tweaks: Fixed inconsistencies in naming of initialFraction,
                    direction, and startDelay (now all named start*).
                </li>
                <li>
                    External Timers: Some people asked for the ability to change
                    the timer that Aniamtor uses (currently the Swing timer).
                    This could be useful in different situations, such as:
                    <ul><li>
                        High-resolution: Some animations might require higher 
                        resolution times than the Swing timer can provide by
                        default. This mechanism allows an application to set up
                        an external timer to provide high-resolution times and
                        tick the Animator more frequently.
                            
                    </li>
                    <li>
                        Non-visual: Animations could be run on back-end or
                        non-visual applications, in which case the Swing timer
                        might not be desired. The original intent of the 
                        TimingFramework was to simplify GUI animations, but
                        if the lack of a non-GUI timer is holding it up from
                        being used elsewhere, this feature removes that
                        constraint. Now another timer, such as java.util.Timer,
                        may be used instead, without the dependency on Swing.
                    </li>
                    <li>
                        Synchronized Animators: Some situations may call for
                        several simultaneous Animators to have synchronized timing
                        events. Instead of each Animator having its own timer
                        set up internally, which is the default, this feature
                        allows a single external TimingSource to send timing 
                        events to several Animators.
                    </li>
                </ul>
                    <p>
                        To use this new feature, create a TimingSource object with
                        your own timer and call Animator.setTimer(TimingSource) to
                        cause Animator to receive events from that external timer
                        instead of its internal timer.
                    </p>
                    <p>
                        Note that I added a new ExternalTimer demo to the
                        demos package to try this out.
                </li>
            </ul>
            <p>January 18, 2007, Version 0.54: Triggers Rock More!</p>
            <p>
                I fixed two things about the Triggers API that have been bugging
                me:
                <ul>
                    <li>
                        StateTrigger: <b>GONE!</b>  It was too painful to have to listen
                        for ChangeEvents, which really have no information in them
                        at all.  This meant that you had to supply a Button to
                        the StateTrigger factor, just so that the Trigger would know
                        the initial values of the ROLLOVER and ARMED states.  Yuck.
                        In its place, I implemented a new MouseTrigger (see below).
                    </li>
                    <li>
                        MouseTrigger: This new trigger listens
                        for simple enter/exit/press/release/click events on
                        any MouseEvent generating thing.  This is not exactly the
                        same thing as a StateTrigger, but should cover basically
                        the same territory, in a much more API-friendly way.
                        (Thanks for the idea, Stephen).
                    </li>
                    <li>
                        Factories + constructors: Triggers originally (and secretly)
                        created a listener and added it to some object that you
                        passed in.  This seemed too mysterious, so the last fix
                        to the API put the responsibility on the caller to actually
                        add the trigger to whatever object (or objects) they wanted.
                        The API was cleaner, but it meant an extra line of code
                        in creating and using a Trigger.<br/>
                        The new approach combines these: each trigger has 
                        constructors, which don't know anything about objects
                        that generate the events (callers must add the trigger
                        to appropriate objects), and factories, which take an
                        object that the trigger will add itself as a listener to.
                        Now the API is clean, but there is a utility method for
                        real use.
                    </li>
                </ul>
                Getting closer to 1.0...
            </p>
            <p>January 10, 2007, Version 0.53: Triggers Rock! (plus minor bug fixes)</p>
            <p>Triggers: After crying myself to sleep for weeks on end over the
            impending loss of Triggers (see the 12/20/06 change log for the
            reasons), I decided to re-work them into a much simpler model.
            I stripped out a lot of the API and all (I hope) of the internal
            ugliness, and created a very simple mechanism for using and
            extending triggers.  Check them out, and the Triggers demo
            app to see what they're about now. This means they'll make 
            version 1.0 and the book!</p>
            <p>Minor bug fixes:</p>
            <ul>
                <li>Animator: now starts from initialFraction correctly depending
                on whether it is moving FORWARD or in REVERSE</li>
                <li>Interpolator: spec now reads that return values from
                interpolate() may be clamped to [0,1]; this was necessary 
                to make KeyFrames not blow up on illegal values due to 
                round-off errors</li>
            </ul>
            <p>December 20, 2006, Version 0.52: Minor API and demo enhancements, plus news</p>
            <p>But first, the <b>news</b>: I plan to freeze a version of the TimingFramework
            soon and call it, for lack of a more catchy name, "1.0".  It will be fairly close
            to what you see today (note that I haven't made any major changes since the
            big refactoring in October).  The reason for freezing is that I want a static/
            known version to be used in the upcoming book ("Filthy Rich Clients", co-authored
            with Romain Guy); the book talks about the API, so the API had better not after
            the book is printed).  Also, SwingLabs wants to start bundling up a "Developer Pack"
            soon, and would like stable version of the API to be included.</p>
            <p>One thing that may not make the cut is the triggers package; I'm just not happy
            with that API yet (very useful, but not very pretty from a code standpoint).  We'll
            have to see if I can whip that into shape Real Soon Now, or else it'll miss 1.0</p>
            <p>Note that work here on this project will continue; versions will just start
            going past 1.0. But for anyone that wants a stable version, I thought you might
            want to know that it's in the works.</p>
            <ul>
                <li>Animator.pause(), Animator.resume(): These methods pause/unpause
                a running animation</li>
                <li>ButtonAnimation: This demo has been enhanced to allow pause/resume/stop
                in addition to the old Go functionality</li>
                <li>TimingExamples-src: By popular request (okay, one person asked for
                it), the demo sources are now available as a standalone zip file.
                Checkout the <A href="https://timingframework.dev.java.net/servlets/ProjectDocumentList">downloads directory</A> 
                to see the stunning result.</li>
            </ul>
            <p>November 13, 2006, Version 0.51: Minor bug fixes, API enhancements</p>
            <ul>
                <li>Animator.cancel(): New method that just stops an Animator in
                its tracks, period.  Just like stop(), only this one doesn't end
                up calling the end() method of the TimingTargets.
                </li>
                <li>Animator bugs: Various minor bugs, such as calling end() before
                the last timingEvent() had been sent, and not handling INFINITE
                durations correctly</li>
                <li>Animator.start() throws an exception if called while running</li>
                <li>Animator.removeTarget(TimingTarget): parallel of addTarget()
                method</li>
                <li>Animator(duration): simplified constructor that doesn't require
                a TimingTarget</li>
                <li>LinearInterpolator, DiscreteInterpolator, and SplineInterpolator
                are all final classes (they were not meant to be subclassed)</li>
                <li>ButtonAnimation demo tweaked to include some of the new
                stuff from the .50 refactoring (initialFraction, direction).</li>
            </ul>
            <p>October 27, 2006, Version 0.5: Refactoring, big and small:
            <ul>
                <li>Version 0.5: About time I added a version number to this thing...</li>
                <li>TimingController has been renamed Animator</li>
                <li>PropertySetter takes the place of the original
                PropertyRange and ObjectModifier classes</li>
                <li>KeySplines has gone away and been replaced by a much
                more flexible and powerful system built on the new Interpolator
                interface.  This interface has one method, interpolate(float),
                that returns an arbitrary number from 0 to 1 given an input 
                number from 0 to 1.  This number will be used to interpolate in
                any given interval.  You can provide an Interpolator to intervals
                in KeyFrames (just like the old KeySplines approach), or you
                can provide an Interpolator to an entire Animator (much like
                acceleration/deceleration control interpolation on an Animator).
                Interpolator has 3 built-in implementations: LinearInterpolator
                (the default for Animator and any KeyFrames interval if no
                other Interpolator is provided), DiscreteInterpolator, and
                SplineInterpolator (which acts like the old KeySplines
                class).</li>
                <li>Evaluator is a new class that provides built-in parametric
                evaluators for various known types.  When you create a 
                KeyValues object with a list of parameters, the system will
                search for an Evaluator that knows how to interpolate between
                these types. If none exists, it will throw and exception.  If
                you need a KeyValues for an unsupported type, create a KeyValues
                with your own Evaluator implementation.</li>
                <li>TimingController.setBegin() has become Animator.setStartDelay():
                I got tired of having a property name that sounded more like
                a method name.  This was a holdover from the SMIL spec that didn't
                fit very well, so I played dictator and changed it.</li>
                <li>TimingListener/TimingEvent went away: I folded in the repeat()
                method into TimingTarget and created an adapter class to make
                it easier to listen to specific events.  Now anyone wishing to
                listen in on timing events does through the TimingTarget interface.</li>
                <li>Triggers: Not much changed here (probably need to look closer
                now that the other stuff is done).  I removed the TimingEvent class
                from the core package, which changed the TimingTriggerEvent
                class, but that's about it.</li>
                <li>Animator is final: There were always two ways to get Animator
                to run animations.  One was to point it at a TimingTarget and
                run it, the other was to subclass Animator and run it instead.
                I found the latter less intuitive and more complex in 
                maintaining, so I opted to simplify and just eliminate
                the subclassing option.</li>
                <li>Simplification: There were various changes made with the aim
                of simplifying the library overall.  For example, there are
                less and yet more logical constructors in various classes.
                Animator, for instance, has only 2 constructors, both of which
                handle common cases, but neither of which handle the gamut of
                property-setting possibilities.  Instead, you are expected to
                call one of the constructors (or clone and existing Animator)
                and call appropriate set* methods as necessary (which probably
                won't be the common case).</li>
            </ul></p>
                <p>
                    I'm probably missing some details here, but this should be the
                    main stuff.  Dig in and have at it...
                </P>
                <p>
                    Some stuff I'm thinking about now includes GUI-focused
                    animations, higher-level effects, and animated transitions.
                </p>
            <p>May 25, 2006: Lots of stuff:
            <ul>
                <li>Put all interpolation classes (PropertyRange, KeyFrames,
                    etc.) in separate package</li>
                <li>Added support for Triggers (in timing.triggers package)</li>
                <li>Removed demos from main library and project and created
                new subproject in demos/ directory.  This cut the framework
                jarfile by over half...</li>
                <li>Minor cleanup on various javadocs and some method
                parameter ordering</li>
                <li>Fixed non-stop REPEAT cycle bug (thanks Owen!) and some
                other roundoff errors in TimingController.actionPerformed()</li>
                <li>Added new demos (Triggers, racetrack.*, and DiscreteInterpolation)</li>
                <li>Added support for doubles in KeyValues (because Romain insisted)</li>
            </ul>
    </body>
</html>
