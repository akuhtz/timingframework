<html>
    <head>
        <title>Timing is Everything</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    </head>
    <body text="#000000" bgColor="#ffffff">
        <center>
        <h1>Timing is Everything</h1>
        <h3>Chet Haase</h3>
        </center>
        <p>Welcome to the <b>Timing Framework</b>, a library for making Java animation
            and timing-based control easier. There are two articles on java.net
            that describe some of the fundamentals: 
            <a href="http://today.java.net/pub/a/today/2005/02/15/timing.html">Timing 
            is Everything</a> and 
            <a href="http://today.java.net/pub/a/today/2006/03/16/time-again.html">Time Again</a>;
            these articles will serve as a good introduction to the framework,
            although some of the API particulars have changed since the articles
            were published.
        </p>
        <h2>The Library</h2>
        <P>The library is divided into three logical parts, which make up the
            three packages:
            <ul>
                <li>Fundamentals: org.jdesktop.animation.timing</li>
                <li>Interpolation: org.jdesktop.animation.timing.interpolation</li>
                <li>Triggers: org.jdesktop.animation.timing.triggers</li>
            </ul>
            </p>
            <p>
            <b>Fundamentals</b> is described fairly completely in the original
            "Timing is Everything" article, although some of the names have
            changed and some of the classes have merged.  
            These classes include the base
            Animator object (which used to be called "TimingController")
            that actually runs the animation and the TimingTarget interface,
            and its adapter class TimingTargetAdapter,
            which are used to receive timing events.
            </p>
            <p>
            <b>Interpolation</b> is desribed in the second article,
            "Time Again", but here are the core concepts:
            <ul>
                <li>
                Property Setters: Easy delegation of property animation to the framework (like 
                changing the size of a component over time, for example).  This
                capability is handled by the class PropertySetter (a class
                which merges the original classes <code>PropertyRange</code> and 
                <code>ObjectModifier</code>.
                </li>
                <li>
                KeyFrames: More powerful and complex animations via multi-step sequences of 
                time/value pairs.  KeyFrames combines the objects <code>KeyTimes</code>,
                <code>KeyValues</code>, and <code>Interpolator</code>.
                </li>
                <li>
                Non-Linear Interpolation: More interesting and useful animations by specifying 
                non-linear paths for time interpolation.  This capability is
                controlled through the use of the <code>Interpolator</code>
                interface, which can be overridden to provide arbitrary 
                interpolation values for any input, or by using one of the
                built-in subclasses: <code>LinearInterpolator</code> (the default
                where none is provided), <code>DiscreteInterpolator</code>, and
                <code>SplineInterpolator</code> (which provides an built-in mechanism
                for creating spline-based interpolation).
                </li>
                <li>
                Acceleration/deceleration: Easy specification of simple non-linear behavior by 
                telling the Animator periods of acceleration and deceleration during 
                the normal time fraction.
                </li>
            </ul>
            <p>
            <b>Triggers</b> contain support
            for easy starting/stopping of animations based on events.  Triggers
            basically wrap EventListener handling for and simplify things
            substantially.  Instead of writing various listeners to track
            events and fire off animations appropriately in your code, 
            you can set up Triggers to do the listening and starting/stopping
            for you.  The intent is to make it easier to have canonical
            effects on GUI components, like pulsating buttons, components
            that animate to a focus state, etc.
            Check out the Triggers demo to see what I mean (until I get a
            chance to document it better than this admittedly brief paragraph).
        </P>
        <p>There are various new and old demos in the demos directory.  You should
        be able to checkout that directory from CVS and get entire build tree
        for NetBeans, or you can just look at the files one by one.  The demos 
        include:
        <ul>
            <li>ButtonAnimation: This is a nuts-and-bolts view of most of the
            capabilities of the framework.  It allows you to tweak the various
            options of the framework and see the effects on basic Swing button
            rendering.</li>
            <li>DiscreteInterpolation: This one is so basic it probably should
            not even be here, but heck I wrote it so I might as well post it.
            It shows how you might use DISCRETE interpolation to change 
            values of objects (in this case, the String displayed in the
            window) over time.  It shows basic usage of the KeyFrames,
            KeyTimes, KeyValues, and SplineInterpolator classes in the
            interpolation package.  It also uses a simple Trigger to kick
            off the animation.</li>
            <li>Triggers: Another unattractive demo, but it shows how you can
            use some of the new Triggers to automatically kick off animations
            based on GUI events.</li>
            <li>Racetrack: There are several demos in this package (BasicRace,
            SetterRace, TriggerRace, NonLinearRace, and MultiStepRace) which were used in
            our JavaOne presentation to show how the various features of the
            framework work.  The demo gets more interesting, and uses more
            framework features, as you progress through the demos in the order
            listed above (MultiStepRace shows off most of the framework
            functionality).  Graphics and sound effects provided by the
            one and only Romain Guy (thanks Romain!)</li>
            <li>SplineEditor: This is a beautiful demo by Romain Guy that
            helps visualize the effect of various Spline curves on any
            particular animation.  You can choose several pre-made Splines or
            drag the points to create your own and see the resulting
            animation.  Great for getting a handle on how spline-based non-linear
            interpolation works in the framework.</li>
        </ul>
        </p>
        <p>
        <h2>Demos</h2>
        <p>To run the demos, download the files from the appropriate version
        in the <A href="https://timingframework.dev.java.net/servlets/ProjectDocumentList">downloads directory</A>.  This directory 
        contains specific versions of the javadocs, library sources,
        demos jarfile, and framework jarfile
            Then you can run any of the demos as follows (note that you'll
            have to adjust the command-line to account for the version
            numbers):
            <pre>
                java -cp TimingFramework.jar;TimingExamples.jar DEMO
            </pre>
            where DEMO is one of:
            <ul>
                <li>org.jdesktop.animation.timing.examples.ButtonAnimation</li>
                <li>org.jdesktop.animation.timing.examples.DiscreteInterpolation</li>
                <li>org.jdesktop.animation.timing.examples.Triggers</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.BasicRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.SetterRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.TriggerRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.NonLinearRace</li>
                <li>org.jdesktop.animation.timing.examples.racetrack.MultiStepRace</li>
                <li>org.jdesktop.animation.timing.examples.editor.SplineEditor</li>
            </ul>
        <P>
            <h2>Project Details</h2>
        </P>
        <p>This project is NetBeans-friendly, so you should be able to download the 
            project and build it easily. I'm running in NetBeans 5.0, in case you need that 
            version to interpret the project files correctly.
        </p>
        <p>The main things to check out here are the Articles mentioned above and
        all of the items in the <A href="https://timingframework.dev.java.net/servlets/ProjectDocumentList">downloads directory</A> 
        (the source code, the library,
        the demos, and the JavaDocs).
            Note that the library is dependent upon JDK 5.0, so 
            you will need 5.0 to run it or build against it.  I use 5.0 because
            generics and varargs helped provide a nice way to get a lot of different
            PropertySetter and KeyValues variants in a very compact way.
        </p>
        <p>The project is still read-only for now; this is because the project is still 
            very much in flux, but it's also because I want to make sure that any 
            interesting developments in the project can be pulled into Java SE if 
            appropriate; after all, if there are useful timing utilities that people need, 
            why not put them into core where they belong? I hope to change that eventually 
            (probably by using a JCA license like SwingLabs does), but for now feel free to 
            browse, download, and build the source, or to just use the library as you see 
            fit. I'm thinking that's all that most people want for now anyway...
        </p>
        <p>
            For those folks that got here by reading the original Timing is Everything 
            article, I've cached a zipped version of the original source code in <A href="articleSrc.zip">
                articleSrc.zip</A>, although I'd just suggest reading the second article 
            and using the current source instead; lots of things in the latest library to 
            make life with Timing Framework much easier than with the original version.
        </p>
        <P>
            Check back for future changes. I think the latest round of changes is quite 
            powerful and will enable some great animations in Swing applications, but 
            there's more work to be done...</P>
        <p>
            <i>I would like to thank Christopher Campbell, Hans Muller, Scott Violet, Romain 
                Guy, and Vincent Hardy for contributing to ideas and code in both the article 
                and project. This article and project took a while to incubate and the 
                assistance of these people hopefully made the end result better than it 
                otherwise would have been.</i>
        </p>
        <P>
            <p>
            <b>Change Log:</b>
            </p>
            <p>November 13, 2006, Version 0.51: Minor bug fixes, API enhancements</p>
            <ul>
                <li>Animator.cancel(): New method that just stops an Animator in
                its tracks, period.  Just like stop(), only this one doesn't end
                up calling the end() method of the TimingTargets.
                </li>
                <li>Animator bugs: Various minor bugs, such as calling end() before
                the last timingEvent() had been sent, and not handling INFINITE
                durations correctly</li>
                <li>Animator.start() throws an exception if called while running</li>
                <li>Animator.removeTarget(TimingTarget): parallel of addTarget()
                method</li>
                <li>Animator(duration): simplified constructor that doesn't require
                a TimingTarget</li>
                <li>LinearInterpolator, DiscreteInterpolator, and SplineInterpolator
                are all final classes (they were not meant to be subclassed)</li>
                <li>ButtonAnimation demo tweaked to include some of the new
                stuff from the .50 refactoring (initialFraction, direction).</li>
            </ul>
            <p>October 27, 2006, Version 0.5: Refactoring, big and small:
            <ul>
                <li>Version 0.5: About time I added a version number to this thing...</li>
                <li>TimingController has been renamed Animator</li>
                <li>PropertySetter takes the place of the original
                PropertyRange and ObjectModifier classes</li>
                <li>KeySplines has gone away and been replaced by a much
                more flexible and powerful system built on the new Interpolator
                interface.  This interface has one method, interpolate(float),
                that returns an arbitrary number from 0 to 1 given an input 
                number from 0 to 1.  This number will be used to interpolate in
                any given interval.  You can provide an Interpolator to intervals
                in KeyFrames (just like the old KeySplines approach), or you
                can provide an Interpolator to an entire Animator (much like
                acceleration/deceleration control interpolation on an Animator).
                Interpolator has 3 built-in implementations: LinearInterpolator
                (the default for Animator and any KeyFrames interval if no
                other Interpolator is provided), DiscreteInterpolator, and
                SplineInterpolator (which acts like the old KeySplines
                class).</li>
                <li>Evaluator is a new class that provides built-in parametric
                evaluators for various known types.  When you create a 
                KeyValues object with a list of parameters, the system will
                search for an Evaluator that knows how to interpolate between
                these types. If none exists, it will throw and exception.  If
                you need a KeyValues for an unsupported type, create a KeyValues
                with your own Evaluator implementation.</li>
                <li>TimingController.setBegin() has become Animator.setStartDelay():
                I got tired of having a property name that sounded more like
                a method name.  This was a holdover from the SMIL spec that didn't
                fit very well, so I played dictator and changed it.</li>
                <li>TimingListener/TimingEvent went away: I folded in the repeat()
                method into TimingTarget and created an adapter class to make
                it easier to listen to specific events.  Now anyone wishing to
                listen in on timing events does through the TimingTarget interface.</li>
                <li>Triggers: Not much changed here (probably need to look closer
                now that the other stuff is done).  I removed the TimingEvent class
                from the core package, which changed the TimingTriggerEvent
                class, but that's about it.</li>
                <li>Animator is final: There were always two ways to get Animator
                to run animations.  One was to point it at a TimingTarget and
                run it, the other was to subclass Animator and run it instead.
                I found the latter less intuitive and more complex in 
                maintaining, so I opted to simplify and just eliminate
                the subclassing option.</li>
                <li>Simplification: There were various changes made with the aim
                of simplifying the library overall.  For example, there are
                less and yet more logical constructors in various classes.
                Animator, for instance, has only 2 constructors, both of which
                handle common cases, but neither of which handle the gamut of
                property-setting possibilities.  Instead, you are expected to
                call one of the constructors (or clone and existing Animator)
                and call appropriate set* methods as necessary (which probably
                won't be the common case).</li>
            </ul></p>
                <p>
                    I'm probably missing some details here, but this should be the
                    main stuff.  Dig in and have at it...
                </P>
                <p>
                    Some stuff I'm thinking about now includes GUI-focused
                    animations, higher-level effects, and animated transitions.
                </p>
            <p>May 25, 2006: Lots of stuff:
            <ul>
                <li>Put all interpolation classes (PropertyRange, KeyFrames,
                    etc.) in separate package</li>
                <li>Added support for Triggers (in timing.triggers package)</li>
                <li>Removed demos from main library and project and created
                new subproject in demos/ directory.  This cut the framework
                jarfile by over half...</li>
                <li>Minor cleanup on various javadocs and some method
                parameter ordering</li>
                <li>Fixed non-stop REPEAT cycle bug (thanks Owen!) and some
                other roundoff errors in TimingController.actionPerformed()</li>
                <li>Added new demos (Triggers, racetrack.*, and DiscreteInterpolation)</li>
                <li>Added support for doubles in KeyValues (because Romain insisted)</li>
            </ul>
    </body>
</html>
